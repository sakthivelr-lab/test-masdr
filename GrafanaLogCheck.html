<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>


    <meta charset="UTF-8">
    <title>Grafana Call Log Parser</title>

    <style>
        body {
            background: #0f172a;
            color: #e5e7eb;
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        textarea {
            width: 100%;
            height: 220px;
            background: #020617;
            color: #e5e7eb;
            border: 1px solid #334155;
            padding: 10px;
            margin-bottom: 12px;
        }

        button {
            padding: 8px 16px;
            background: #2563eb;
            border: none;
            color: white;
            cursor: pointer;
            margin-bottom: 16px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th,
        td {
            border: 1px solid #334155;
            padding: 6px;
            vertical-align: top;
        }

        th {
            background: #020617;
            color: #93c5fd;
        }

        tr:nth-child(even) {
            background: #020617;
        }

        .wrap {
            max-width: 260px;
            word-break: break-word;
        }

        .basic {
            background: white;
            padding: 30px;
            color: black;
            line-height: 26px;
        }

        .basic span {
            color: red;
        }

        .hidden {
            display: none;
        }

        /* Scroll buttons */
        .scroll-btn {
            position: fixed;
            right: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #111827;
            color: #fff;
            border: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            z-index: 9999;
        }

        #scrollUpBtn {
            bottom: 88px;
        }

        #scrollDownBtn {
            bottom: 20px;
        }

        .scroll-btn:hover {
            transform: translateY(-2px);
        }

        /* Diff highlight when > 10 minutes */
        .long-diff {
            color: #f87171;
            /* red-400 */
            font-weight: 600;
        }

        /* Scrollable cell for long entry logs */
        .scrollable {
            max-height: 140px;
            overflow: auto;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
            padding: 6px;
            background: #020617;
            color: #e5e7eb;
            border-radius: 4px;
        }

        /* (removed clickable row highlight) */
    </style>
</head>

<body>

    <h2>üìû Grafana Call Log Debugger</h2>

    <textarea id="logInput" placeholder="Paste Grafana <tbody> HTML here..."></textarea>
    <br>
    <button id="logFn" onclick="parseGrafanaHTML()">Parse Logs</button>
    <button onclick="reset()">Reset Logs</button>
    <button id="addFromLogsBtn" onclick="addInteractionToUI()">Generate RCA from Logs</button>
    <button onclick="shareLink()">Share This Log</button>

    <!-- Floating scroll buttons -->
    <button id="scrollUpBtn" class="scroll-btn" title="Scroll up (dblclick = top)" aria-label="Scroll up">‚ñ≤</button>
    <button id="scrollDownBtn" class="scroll-btn" title="Scroll down (dblclick = bottom)"
        aria-label="Scroll down">‚ñº</button>



    <div id="loader" class="hidden">
        <p>Loading....</p>
    </div>
    <div>
        <h1>Basic Info About call</h1>
        <p class="basic" id="basicInfo"></p>
    </div>


    <div>
        <h2>RCA Panel</h2>
        <div id="interactionPanel" class="basic" style="min-height:40px;"></div>
    </div>


    <table>
        <thead>
            <tr>
                <th>Title</th>
                <th>Date Time</th>
                <th>Date Time diff</th>
                <th>Local User JID</th>
                <th>Interaction ID</th>
                <th>Role</th>
                <th>User Domain</th>
                <th>Message</th>
                <th>Room ID</th>
                <th>Remote User JID</th>
                <th>Data</th>
                <th>entrieLog Text</th>
            </tr>
        </thead>
        <tbody id="result"></tbody>
    </table>

    <script>


        window.onload = function () {
            if (location.hash.length > 1) {
                const compressed = location.hash.substring(1);
                const log = LZString.decompressFromEncodedURIComponent(compressed);
                if (log) {
                    document.getElementById("logInput").value = log;
                }
            }
        };
        function showLoader() {
            loader = true;
            document.getElementById("loader")?.classList.remove("hidden");
        }

        function hideLoader() {
            loader = false;
            document.getElementById("loader")?.classList.add("hidden");
        }

        let loader = false;

        hideLoader();
        let localStorageData = localStorage.getItem("log");

        if (localStorageData) {
            localStorageData = JSON.parse(localStorageData);
            document.getElementById("logInput").innerHTML = localStorageData;
        };

        function reset() {
            loader = false;
            document.getElementById("loader").style.display = "none"
            localStorage.clear();
            document.getElementById("logInput").innerHTML = "";
            document.getElementById("logInput").value = "";
            document.getElementById("result").innerHTML = ""
            basicInfo = {};
            document.getElementById("basicInfo").innerHTML = "";
            document.getElementById("rcaOutput").innerHTML = "";
            document.getElementById("interactionPanel").innerHTML = "";
            parsedDetailsLogs = [];
            window.parsedDetails = {}

        }
    </script>

    <!-- Additional global scroll handlers: click = page, dblclick = full top/bottom -->
    <script>
        (function () {
            function pageUp() {
                try { window.scrollBy({ top: -window.innerHeight, left: 0, behavior: 'smooth' }); }
                catch (e) { window.scrollTo(0, Math.max(0, window.scrollY - window.innerHeight)); }
            }

            function pageDown() {
                try { window.scrollBy({ top: window.innerHeight, left: 0, behavior: 'smooth' }); }
                catch (e) { window.scrollTo(0, window.scrollY + window.innerHeight); }
            }

            function toTop() {
                try { window.scrollTo({ top: 0, left: 0, behavior: 'smooth' }); }
                catch (e) { window.scrollTo(0, 0); }
            }

            function toBottom() {
                try { window.scrollTo({ top: document.documentElement.scrollHeight || document.body.scrollHeight, left: 0, behavior: 'smooth' }); }
                catch (e) { window.scrollTo(0, document.body.scrollHeight); }
            }

            const up = document.getElementById('scrollUpBtn');
            const down = document.getElementById('scrollDownBtn');

            if (up) {
                up.addEventListener('click', pageUp);
                up.addEventListener('dblclick', toTop);
            }

            if (down) {
                down.addEventListener('click', pageDown);
                down.addEventListener('dblclick', toBottom);
            }

            // Optional: show a small tooltip on dblclick behavior via title update
            if (up && up.title && !up.title.includes('dblclick')) up.title += ' (dblclick = top)';
            if (down && down.title && !down.title.includes('dblclick')) down.title += ' (dblclick = bottom)';
        })();
    </script>

    <script>


        let basicInfo = {}

        let parsedDetailsLogs = []

        function cleanHTML(html) {
            const div = document.createElement("div");
            div.innerHTML = html;

            // remove <mark> but keep text
            div.querySelectorAll("mark").forEach(m => m.replaceWith(m.textContent));

            let text = div.textContent || "";
            return text.replace(/&rlm;|\u200f|\u200e/g, "");
        }

        function formatDiffTime(ms) {
            if (ms < 1000) return `${ms} ms`;
            if (ms < 60000) return `${(ms / 1000).toFixed(2)} sec`;
            return `${(ms / 60000).toFixed(2)} min`;
        }

        // escape HTML to safely show raw log text inside a cell
        function escapeHTML(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }




        // FIXED: Grab full logDetails including escaped quotes
        function extractLogDetails(text) {

            const regex = /"logDetails":"((?:[^"\\]|\\.)*)"/g;
            const matches = [...text.matchAll(regex)];

            const timestampRegex = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+)/gm;
            const timestamps = [...text.matchAll(timestampRegex)].map(m => m[1]);

            // return matches.map((m, index) => ({
            //     logDetails: m[1],
            //     time: timestamps[index] || null,
            //     diffTime: index > 2 && timestamps[index - 1] - timestamps[index]
            // }));

            return matches.map((m, index) => {
                const current = timestamps[index]
                    ? new Date(timestamps[index]).getTime()
                    : null;

                const next = timestamps[index + 1]
                    ? new Date(timestamps[index + 1]).getTime()
                    : null;

                const diffMs =
                    current && next
                        ? Math.abs(next - current)
                        : null;

                return {
                    logDetails: m[1],
                    time: timestamps[index] || null,
                    diffTime: diffMs !== null ? formatDiffTime(diffMs) : "-",
                    diffMs: diffMs
                };
            });
        }

        function extractImageLog(text) {
            // timestamp (first one only)
            const timeMatch = text.match(
                /\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+/
            );

            // base64 image
            const imageMatch = text.match(
                /(data:image\/[a-zA-Z]+;base64,[A-Za-z0-9+/=]+)/
            );

            return {
                imageMatch,
                text: ""
            };
        }

        function cleanReconnectionOrder(reconnection = []) {
            const userMap = {};

            // Group by user (parts[2])
            reconnection.forEach(item => {
                const [, user] = item;
                if (!userMap[user]) userMap[user] = [];
                userMap[user].push(item);
            });

            const result = [];

            Object.values(userMap).forEach(entries => {
                // sort by time
                entries.sort((a, b) => new Date(a[0]) - new Date(b[0]));

                let initiateIndex = -1;
                let clearIndex = -1;

                entries.forEach((e, i) => {
                    if (e[2] === "initiate reconnection timer") initiateIndex = i;
                    if (e[2] === "Clear reconnection waiting timer") clearIndex = i;
                });

                // ‚ùå If initiate comes before clear ‚Üí remove both
                if (
                    initiateIndex !== -1 &&
                    clearIndex !== -1 &&
                    initiateIndex < clearIndex
                ) {
                    return; // skip adding anything
                }

                // ‚úÖ Otherwise keep entries
                result.push(...entries);
            });

            return result;
        }


        function safeJSON(str) {
            try { return JSON.parse(str); } catch { return str; }
        }



        const checkinfo = (message, mtch) => {

            let info = String(message).match(mtch);

            if (info) {

                return info[0];
            }
            return false;
        }

        function rcaCreation({ message, entrieLog, localUserJid, interactionId, roomId, datetime }) {

            const getUserNamesFromMessage = (message) => {
                try {
                    // Extract JSON array part from the message
                    if (!message || typeof message !== "string") return [];

                    // 1. Try to extract last JSON array part [ ... ]
                    const arrayMatch = message.match(/\[(.*)\]$/);

                    console.log(arrayMatch, 'arrayMatch');

                    if (arrayMatch) {
                        const jsonText = `[${arrayMatch[1]}]`;
                        return JSON.parse(jsonText);
                    }
                    const parsed = JSON.parse(message);
                    // return Array.isArray(parsed) ? parsed : [];
                    const names = parsed
                        .filter(u => !u.localUser && u.name)
                        .map(u => u.name);

                    return names;
                } catch (e) {
                    return [];
                }
            };



            try {

                window.parsedDetails = {
                    ...window.parsedDetails,
                    interactionId,
                    roomId
                };
                let isCutomer = String("9962@cx-xmpp.masdr.org").length == localUserJid.length;

                let basicInfoLog = {
                    logs: entrieLog,
                    jid: localUserJid,
                    time: datetime,
                    isCutomer

                }

                if (checkinfo(message, "received message created")) {
                    parsedDetailsLogs.push({
                        title: "Customer Room Created and Call Initiated",
                        ...basicInfoLog
                    });

                }

                if (checkinfo(message, "Incomingcall received")) {
                    parsedDetailsLogs.push({
                        title: "Incomming Call Reviced to Agent",
                        ...basicInfoLog

                    });
                }

                if (checkinfo(message, 'Incoming Call Popup Mounted')) {
                    parsedDetailsLogs.push({
                        title: "Incomming Call Reviced to Agent and UI showing",
                        ...basicInfoLog

                    });
                }

                if (String(message).includes("Calling from call component")) {

                    console.log(checkinfo(message, 'Calling from call component'))
                    const names = getUserNamesFromMessage(message);

                    console.log(names);

                }


                if (checkinfo(message, 'Calling from call component')) {
                    const names = getUserNamesFromMessage(message);

                    if (names.length > 0) {
                        parsedDetailsLogs.push({
                            title: `User List For Call of ${isCutomer ? 'Customer' : 'Agent'}`,
                            ...basicInfoLog,
                            subtitleHtml: `
                <ul>
                    ${names.map(name => `<li>${name}</li>`).join('')}
                </ul>
            `
                        });
                    }
                }



            } catch (error) {

                console.log(error, 'err');

            }

        }

        async function renderBasicInfo() {
            basicInfo.reconnection = await cleanReconnectionOrder(basicInfo.reconnection);
            const htmlOutput = Object.entries(basicInfo)
                .map(([key, value]) => {
                    // If value is an array
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return `<b>${key}</b> : -`;
                        }

                        const list = value
                            .map((item, index) => {
                                // handle array inside array (like reconnection logs)
                                if (Array.isArray(item)) {
                                    return `${index + 1}) ${item.join(" | ")}`;
                                }
                                return `${index + 1}) ${item}`;
                            })
                            .join("<br>");

                        return `<b>${key}</b> :<br>${list}`;
                    }

                    // Normal value
                    return `<b>${key}</b> : ${value ?? "-"}`;
                })
                .join("<br><br>");

            document.getElementById("basicInfo").innerHTML = htmlOutput;
        }

        // Insert parsedDetailsLogs entries sorted by time (ascending). If time is invalid, append at end.

        // Sort parsedDetailsLogs (ascending by time) and render into UI
        function sortParsedDetailsLogs() {


            parsedDetailsLogs.sort((a, b) => {
                const ta = a && a.time ? new Date(a.time).getTime() : NaN;
                const tb = b && b.time ? new Date(b.time).getTime() : NaN;
                if (isNaN(ta) && isNaN(tb)) return 0;
                if (isNaN(ta)) return 1;
                if (isNaN(tb)) return -1;
                return ta - tb;
            });
            return parsedDetailsLogs;
        }

        // Render parsedDetailsLogs into #parsedLogsPanel

        function parseLogDetails(log, time, rest) {

            const parts = [...log.matchAll(/\[([^\]]+)\]/g)].map(m => m[1]);

            // if (String(parts[0]).match("Call-UI")) {

            //     return {
            //         title: parts[0] || "-",
            //         datetime: time,
            //         localUserJid: "-",
            //         interactionId: "-",
            //         role: "-",
            //         userdomain: "getJSON()",
            //         diffTime: "-",
            //         message: "message",
            //         roomId: "-",
            //         remoteUserjid: "-",
            //         entrieLog: "-",
            //         remoteUserjid: "-",
            //         data: "-",
            //         dashboardText: "-",

            //     }
            // }


            const getJSON = (key) => {
                const m = log.match(new RegExp(`\\{\\s*"${key}"\\s*":([^}]+)\\}`));
                return m ? safeJSON(`{"${key}":${m[1]}}`)[key] : "-";
            };


            function extractValueFromLog(log, key) {
                const unescaped = log.replace(/\\"/g, '"');
                const regex = new RegExp(`\\{[^{}]*"${key}"\\s*:\\s*"([^"]+)"[^{}]*\\}`, "g");
                const match = regex.exec(unescaped);
                return match ? match[1] : "-";
            }


            const message = (() => {


                let msg = log;

                msg = msg.replace(/\\"/g, '"')
                    .replace(/\\n/g, " ")
                    .replace(/\\t/g, " ")
                    .replace(/\\\\/g, "\\");

                msg = msg.replace(/^(\[[^\]]+\]\s*){5}/, "").trim();

                msg = msg.replace(/\{(?:\\.|[^{}])*?\}/g, "").trim();

                return msg || "-";
            })()



            if (String(message).match("Calling from call component remoteCount")) {

                let user = String(parts[4] + "-" + parts[2]).trim();
                basicInfo["Call_visited"] = [
                    ...new Set([...(basicInfo["Call_visited"] || []), user])
                ];
            }

            if (String(message).match("send endCall")) {
                let user = String(parts[4] + "---------" + parts[2]).trim();
                basicInfo["call_end_by"] = user;
            }

            if (String(message).match("Incoming Call Popup Mounted")) {
                let user = String(parts[4] + "-" + parts[2]).trim();
                basicInfo["Incoming_Call_Pop_shown"] = [
                    ...new Set([...(basicInfo["Incoming_Call_Pop_shown"] || []), user])
                ];

            }

            if (String(message).match("Answer call processing")) {
                let user = String(parts[4] + "-" + parts[2]).trim();
                basicInfo["AnswerTime"] = time;
                basicInfo["Answered_by"] = user;
            }


            if (String(message).match("send endCall") && !basicInfo["EndTime"]) {
                basicInfo["EndTime"] = time;
            }

            if (basicInfo["EndTime"] && basicInfo["AnswerTime"] && !basicInfo["Total_call_Time"]) {

                const end = new Date(basicInfo.EndTime);
                const answer = new Date(basicInfo.AnswerTime);

                // Only calculate if EndTime is AFTER AnswerTime
                if (end >= answer) {
                    const diffMs = end - answer;
                    basicInfo.Total_call_Time = formatDiffTime(diffMs);
                } else {
                    // invalid order ‚Üí set 0 duration or flag
                    basicInfo.Total_call_Time = "0hr 0m 0sec";
                }

            }

            const match = String(message).match(
                /initiate reconnection timer|Clear reconnection waiting timer/
            );

            if (match) {

                if (!basicInfo.reconnection) {
                    basicInfo.reconnection = [];
                }

                basicInfo.reconnection.push([time, parts[2], match[0]]);
            }


            let env = getJSON("isWebView");


            if (env && env != "-" && !basicInfo.environment) {
                basicInfo.environment = env;
            }


            let responce = {
                title: parts[0] || "-",
                datetime: time || "inside TIME" + parts[1] || "-",
                localUserJid: parts[2] || "-",
                interactionId: parts[3] || "-",
                role: parts[4] || "-",
                userdomain: getJSON("userdomain"),
                diffTime: rest?.diffTime,
                message: message,
                roomId: extractValueFromLog(log, "roomId"),
                remoteUserjid: extractValueFromLog(log, "remoteUserjid"),
                entrieLog: log,
                remoteUserjid: (() => {
                    const match = log.match(/"remoteUserjid"\s*:\s*"([^"]+)"/);
                    return match ? match[1] : "-"
                })(),

                // remoteUserjid: getJSON("remoteUserjid"),
                data: getJSON("xmppStatus") !== "-" ? log.match(/\{.*CONNECTED.*\}/)?.[0] || "-" : "-",
                dashboardText: log.includes("dashboard") ? log.match(/"([^"]+)"$/)?.[1] || "-" : "-"
            }

            if (String(responce.title).match("Incoming-Call-UI-BASE64") || String(responce.message).startsWith("Incoming Call Pop Base")) {
                responce.message = "Base 64 big log"
            }


            return { ...responce };
        }

        async function parseGrafanaHTML() {

            try {


                if (loader) {
                    return;
                }

                basicInfo = {};
                showLoader()
                const input = document.getElementById("logInput").value;
                localStorage.setItem("log", JSON.stringify(input));
                const tbody = document.getElementById("result");
                tbody.innerHTML = "";
                const cleanText = cleanHTML(input);

                let logs = null;

                logs = extractLogDetails(cleanText);





                // store parsed details for other features (RCA generation)
                window.parsedDetails = {};
                parsedDetailsLogs = [];


                await logs.forEach((log, index) => {
                    const { logDetails, time, ...rest } = log;

                    console.log(log, 'logsss');


                    const d = parseLogDetails(logDetails, time, rest);

                    rcaCreation(d);
                    // collect a lightweight version for RCA

                    basicInfo.interactionId = d.interactionId;

                    // detect long diff (> 10 minutes)
                    const isLongDiff = typeof rest.diffMs === 'number' && rest.diffMs > 1.5 * 60 * 1000;


                    tbody.innerHTML += `
                <tr>
                    <td>${d.title}</td>
                    <td>${d.datetime}</td>
                    <td ${isLongDiff ? 'class="long-diff"' : ''}>${d.diffTime}</td>
                    <td class="wrap">${d.localUserJid}</td>
                    <td>${d.interactionId}</td>
                    <td>${d.role}</td>
                    <td>${d.userdomain}</td>
                    <td class="wrap">${d.message}</td>
                    <td>${d.roomId}</td>
                    <td class="wrap">${d.remoteUserjid}</td>
                    <td class="wrap">${d.data}</td>
                    <td class="wrap"><div class="scrollable">${escapeHTML(d.entrieLog)}</div></td>
                </tr>
            `;
                });


                basicInfo.reconnection = cleanReconnectionOrder(basicInfo.reconnection || []);

                renderBasicInfo()
                hideLoader();

                // clear previous RCA output when parsing new logs
                document.getElementById('rcaOutput').innerText = '';


            } catch (error) {
                hideLoader()
            }

            // Scroll helpers: scroll one viewport up/down smoothly
            function scrollUp() {
                try {
                    window.scrollBy({ top: 0, left: 0, behavior: 'smooth' });
                } catch (e) {
                    // fallback
                    window.scrollTo(0, Math.max(0, window.scrollY - window.innerHeight));
                }
            }

            function scrollDown() {
                try {
                    window.scrollBy({ top: window.innerHeight, left: 0, behavior: 'smooth' });
                } catch (e) {
                    // fallback
                    window.scrollTo(0, window.scrollY + window.innerHeight);
                }
            }

            // Attach event listeners for the buttons (safe-guard if elements missing)
            document.getElementById('scrollUpBtn')?.addEventListener('click', scrollUp);
            document.getElementById('scrollDownBtn')?.addEventListener('click', scrollDown);
        }


        async function shareLink(params) {
            const input = document.getElementById("logInput").value;
            if (!input) {
                alert("Somting went wrong");
            }
            const docClone = document.documentElement.cloneNode(true);

            docClone.querySelectorAll("button").forEach(btn => {
                if (btn.innerText.includes("Export")) btn.remove();
            });

            const html =
                "<!DOCTYPE html>\n" +
                docClone.outerHTML;

            // Download as file
            const blob = new Blob([html], { type: "text/html" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${basicInfo.interactionId}shared-page.html`;
            a.click();
        }

        // Add Interaction into the Interaction Panel using parsed log data (if available)
        async function addInteractionToUI() {
            const panel = document.getElementById('interactionPanel');
            if (!panel) return;

            let details = window.parsedDetails || {};

            panel.innerHTML = `
                <h3>RCA ‚Äì Interaction ${details.interactionId}</h3>
                <p><b>Interaction ID:</b> ${details.interactionId}<br><b>Room ID:</b> ${details?.roomId}</p>
            `;

            const l = await sortParsedDetailsLogs();
            console.log(l, 'list');


            if (l.length > 0) {
                panel.innerHTML += `
        <p><b>Logs:</b></p>
        <ul>
            ${l.map(item => `
                <li>
                    <b>Title:</b> ${item.title} <br>

                    ${item.subtitleHtml
                        ? `<b>Subtitle:</b><br>${item.subtitleHtml}`
                        : ''
                    }

                    <b>Evidence:</b> ${item.logs} <br>
                    <small>Time: ${item.time}</small>
                </li>
            `).join('')}
        </ul>
    `;
            }
            else {
                panel.innerHTML += '<p><b>No logs found.</b></p>';
            }

        }

        // Scroll to the bottom of the page
        function scrollDown() {
            const panel = document.getElementById('interactionPanel');
            if (!panel) return;

            try {
                panel.scrollIntoView({ behavior: 'smooth' });
            } catch (e) {
                // fallback
            }

            panel.scrollIntoView({ behavior: 'smooth' });
        }

    </script>

</body>

</html>